/**
 * Check if data is json
 * @param  {Object} data json data
 */
const isJson = (data) => {
  try {
    JSON.parse(data);
  } catch {
    return false;
  }

  return true;
};

/**
 * Get records from Cpanel API response
 * @param  {Object} data object
 */
const getRecorsFromData = (data) => {
  const json = isJson(data) ? JSON.parse(data) : data;
  const {
    data: [response]
  } = json;

  return response.record;
};

/**
 * Group JSON object by DNS type
 * @param  {Array} records items of records
 * @param  {String} type DNS type
 */
const groupByType = (records, type) => {
  const groups = records
    // eslint-disable-next-line unicorn/no-array-callback-reference
    .map(typeof type === 'function' ? type : (value) => value[type])
    // eslint-disable-next-line unicorn/no-array-reduce
    .reduce((acc, value, i) => {
      acc[value] = (acc[value] || []).concat(records[i]);
      return acc;
    }, {});
  return groups;
};

/**
 * Compose functions from left to right
 * @param  {Array} fns functions to compose
 * @param  {Object} x data to return
 */
// eslint-disable-next-line unicorn/no-array-reduce
const pipe = (...fns) => (x) => fns.reduce((y, f) => f(y), x);

/**
 * Simple document for the DNS zone file
 * @param  {String} domain Specify a domain
 * @param  {String} datetime Specify a date of generation or autogenerated
 * @param  {String} records DNS Records
 */
const zoneFile = (domain, datetime, records) => {
  const date = datetime || new Date().toISOString();
  return `;;\n;; Domain: ${domain}\n;; Date: ${date}\n;;\n\n${records}`;
};

/**
 * Records header for each DNS type
 * @param  {String} type e.g. A, TXT, MX
 */
const recordsHeader = (type) => `;; ${type} Records\n`;

const recordsFormat = {
  A(data) {
    return `${data.name}\t${data.ttl}\t${data.class}\t${data.type}\t${data.record}`;
  },
  AAA(data) {
    return `${data.name}\t${data.ttl}\t${data.class}\t${data.type}\t${data.record}`;
  },
  CNAME(data) {
    return `${data.name}\t${data.ttl}\t${data.class}\t${data.type}\t${data.record}`;
  },
  TXT(data) {
    return `${data.name}\t${data.ttl}\t${data.class}\t${data.type}\t"${data.record}"`;
  },
  MX(data) {
    return `${data.name}\t${data.ttl}\t${data.class}\t${data.type}\t${data.preference} ${data.exchange}`;
  },
  SRV(data) {
    return `${data.name}\t${data.ttl}\t${data.class}\t${data.type}\t${data.priority} ${data.weight} ${data.port}\n${data.target}`;
  },
  CA(data) {
    return `${data.name}\t${data.ttl}\t${data.class}\t${data.type}\t${data.flag} ${data.tag} "${data.value}"`;
  },
  mapRecords(type, data) {
    return data.map((record) => this[type](record));
  },
  formatSection(type, data) {
    return `${recordsHeader(type)}${this.mapRecords(type, data).join('\n')}\n`;
  }
};

export {
  getRecorsFromData,
  groupByType,
  isJson,
  pipe,
  recordsFormat,
  recordsHeader,
  zoneFile
};
